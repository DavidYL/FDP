---
title: "Longitudinal analysis"
author: "David Mui√±a"
date: "2024-01-17"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dev = "svg", message = FALSE)
```

```{r packages}

library(readxl)
library(kableExtra)
library(compareGroups)
library(dplyr)
library(lubridate)
library(tidyr)
library(rmarkdown)
library(boot)
library(ggplot2)
library(lm.beta)
library(excel.link)
library(openxlsx)
library(car)
library(multcomp)
library(lme4)
library(lmerTest)
library(MASS)
library(scales)
library(lmtest)
library(stats)
library(plotly)
library(tidyverse)
library(patchwork)
```


```{r read_dataset}

df <- xl.read.file("longitudinal_dataset_20240111_password_2.xlsx", password = "bbrc_2024")

set.seed(123)

# Remove current row names
row.names(df) <- NULL

# Reset row names to start from 1
row.names(df) <- 1:nrow(df)
```

### ptau217 and ttau data preparation
```{r}

tau <- xl.read.file("19Feb2024_BBRC_Plasma and CSF Samples_P-tau217 and T-tau.xlsx")

# Remove the first row and first column
tau <- tau[-1, -1]

# Assign column names based on the values in the first row
colnames(tau) <- tau[1, ]

# Remove the first row again
tau <- tau[-1, ]

# Remove current row names
row.names(tau) <- NULL

# Reset row names to start from 1
row.names(tau) <- 1:nrow(tau)

# Convert some columns from character type to numeric type
tau$`Conc (pg/mL)_217` <- as.numeric(tau$`Conc (pg/mL)_217`)
tau$`%CV_217` <- as.numeric(tau$`%CV_217`)
tau$`%CV_tt` <- as.numeric(tau$`%CV_tt`)
tau$`Conc (pg/mL)_tt` <- as.numeric(tau$`Conc (pg/mL)_tt`)

# Check the structure
str(tau)

# Filter rows in the 'tau' dataframe where values in columns '%CV_217' and '%CV_tt' are less than or equal to 20
tau_correct <- tau %>%
  filter(`%CV_217` <= 20) %>% filter(`%CV_tt` <= 20)

#Select interest columns
tau_correct <- tau_correct  %>% dplyr::select(Participant, `Conc (pg/mL)_217`, `Conc (pg/mL)_tt`)

# Rename columns
colnames(tau_correct) <- c("ParticipantID", "ptau217_plasmaF_MSDLilly_FU", "ttau_plasmaF_MSDLilly_FU")

# Arrange rows based on the "ParticipantID" column
tau_correct <- tau_correct %>%
  arrange(ParticipantID)

# Merge the two data frames based on the "ParticipantID" column
df <- merge(df, tau_correct, by = "ParticipantID", all.x = TRUE)


```




```{r}
# Read Excel file into dataframe "janssen"
janssen <- xl.read.file("ALFA+_Janssen plasma p217+tau_password_Dec2023_2.xlsx", password = "ALFA-JJIM")

# Select specific columns in "janssen" dataframe
janssen <- janssen %>% dplyr::select("Sample ID", "Dilution Corrected Conc. (pg/mL)", "JJIM_notes")

# Remove current row names
row.names(janssen) <- NULL

# Remove rows from 1 to 33 in the "janssen" dataframe
janssen <- janssen %>% slice(34:n())

# Read Excel file into dataframe "shipment"
shipment <- xl.read.file("Janssen_V0.1.2_Shipment.xlsx")

# Filter "shipment" dataframe to include only rows where ID ends with V1 or V2
shipment <- shipment %>%
  filter(grepl("V[12]$", ID))

# Match indices of "Sample ID" in "janssen" with "TUBE ID LVL" in "shipment"
matching_indices <- match(janssen$`Sample ID`, shipment$`TUBE ID LVL `)

# a <- janssen[grepl("QE232141P", janssen$`Sample ID`), ]

# Filter "janssen" dataframe based on matching indices
janssen <- janssen[!is.na(matching_indices), ]

# Remove rows from 1 to 19 in the "shipment" dataframe
shipment <- shipment %>% slice(20:n())

# Add the "ID" column from "shipment" to "janssen"
janssen$ID <- shipment$ID

# Extract ParticipantID from ID column
janssen <- janssen %>%
  mutate(ParticipantID = sub("_.*", "", ID))

# Read Excel file into dataframe "janssen"
janssen <- xl.read.file("ALFA+_Janssen plasma p217+tau_password_Dec2023_2.xlsx", password = "ALFA-JJIM")

# Select specific columns in "janssen" dataframe
janssen <- janssen %>% dplyr::select("Sample ID", "Dilution Corrected Conc. (pg/mL)", "JJIM_notes")

# Remove current row names
row.names(janssen) <- NULL

# Remove rows from 1 to 33 in the "janssen" dataframe
janssen <- janssen %>% slice(34:n())

# Read Excel file into dataframe "shipment"
shipment <- xl.read.file("Janssen_V0.1.2_Shipment.xlsx")

# Filter "shipment" dataframe to include only rows where ID ends with V1 or V2
shipment <- shipment %>%
  filter(grepl("V[12]$", ID))

# Match indices of "Sample ID" in "janssen" with "TUBE ID LVL" in "shipment"
matching_indices <- match(janssen$`Sample ID`, shipment$`TUBE ID LVL `)

# Filter "janssen" dataframe based on matching indices
janssen <- janssen[!is.na(matching_indices), ]

# Remove rows from 1 to 19 in the "shipment" dataframe
shipment <- shipment %>% slice(20:n())

# Add the "ID" column from "shipment" to "janssen"
janssen$ID <- shipment$ID

# Extract ParticipantID from ID column
janssen <- janssen %>%
  mutate(ParticipantID = sub("_.*", "", ID))

# Create new dataframe "new_jan" with BL and FU columns
new_jan <- janssen %>%
  group_by(ParticipantID) %>%
  summarise(
    ptau217_plasmaNF_SimoaJanssen_BL = `Dilution Corrected Conc. (pg/mL)`[grepl("_V1$", ID)],
    ptau217_plasmaNF_SimoaJanssen_FU = `Dilution Corrected Conc. (pg/mL)`[grepl("_V2$", ID)]
  )
# remove(janssen, shipment)

new_jan$ptau217_plasmaNF_SimoaJanssen_BL <- as.numeric(new_jan$ptau217_plasmaNF_SimoaJanssen_BL)
new_jan$ptau217_plasmaNF_SimoaJanssen_FU <- as.numeric(new_jan$ptau217_plasmaNF_SimoaJanssen_FU)

# Merge df with new_jan by ParticipantID
df <- merge(df, new_jan, by = "ParticipantID", all.x = TRUE)

df %>% dplyr::select("ParticipantID", "ptau217_plasmaNF_SimoaJanssen_BL", "ptau217_plasmaNF_SimoaJanssen_FU")
```




### Subset dataframe with variables of interest
```{r subset}

biomark_variables <- c(
  "ParticipantID",
  "Age_V1S1",
  "Sex",
  "APOE_binary",                           
  "APOE_class",
  "APOE_consensus",
  "A_status_BL",                           
  "A_status_FU",
  "T_status_BL",                          
  "T_status_FU",
  "AT_status_BL",
  "AT_status_FU",                          
  "ATN_status_BL",
  "ATN_status_FU",
  "V1S1_dt",
  "V2S1_dt",
  "amyloid_PET_CL_BL_complete",
  "amyloid_PET_Centiloid_BL",
  "amyloid_PET_Centiloid_FU",
  "Ab42_CSFNC_RocheNTK_BL",
  "Ab40_CSFNC_RocheNTK_BL",
  "Ab40_plasmaF_SimoaNP4E_BL",
  "Ab40_plasmaF_SimoaNP4E_FU",
  "Ab42_40_ratio_plasmaF_SimoaNP4E_BL",
  "Ab42_40_ratio_plasmaF_SimoaNP4E_FU",
  "Ab42_plasmaF_SimoaNP4E_BL",
  "Ab42_plasmaF_SimoaNP4E_FU",
  "ptau181_plasmaF_Simoa_BL",              
  "ptau181_plasmaF_Simoa_FU",
  "ptau217_plasmaF_MSDLilly_BL",
  "ptau217_plasmaF_MSDLilly_FU",
  "ptau217_plasmaNF_SimoaJanssen_BL",
  "ptau217_plasmaNF_SimoaJanssen_FU",
  "ptau231_plasmaF_SimoaGot_BL",
  "ptau231_plasmaF_SimoaGot_FU",
  "ttau_plasmaF_MSDLilly_BL",
  "ttau_plasmaF_MSDLilly_FU",
  "GFAP_plasmaF_SimoaNP4E_BL",
  "GFAP_plasmaF_SimoaNP4E_FU",
  "NFL_plasmaF_SimoaNP4E_BL",
  "NFL_plasmaF_SimoaNP4E_FU"
)

# Subset the data for the selected variables
biomark_df <- df[, biomark_variables]


# Create the ab42_40_ratio_CSFNC_BL proxy variable
biomark_df$ab42_40_ratio_CSFNC_BL <- biomark_df$Ab42_CSFNC_RocheNTK_BL/biomark_df$Ab40_CSFNC_RocheNTK_BL

# Change data type of interest variables
biomark_df$Age_V1S1 <- as.numeric(biomark_df$Age_V1S1)
biomark_df$Sex <- as.factor(biomark_df$Sex)
biomark_df$APOE_binary <- as.factor(biomark_df$APOE_binary)


sum(!is.na(biomark_df$V2S1_dt))
```


### Calculate difference between FU-BL

```{r}

time_cols <- c("V1S1_dt", "V2S1_dt")

# Convert date strings to Date objects
biomark_df[, paste0(time_cols)] <- lapply(biomark_df[, time_cols], as.Date, format = "%d/%m/%Y")

# Calculate the time difference in days
biomark_df$days_diff <- as.numeric(difftime(biomark_df$V2S1_dt, biomark_df$V1S1_dt, units = "days"))



biomark_df[c("Ab40_diff", "Ab42_40_ratio_diff", "Ab42_diff", 
                      "ptau181_diff", "ptau231_diff",
                      "ptau217_Lilly_diff", "ptau217_Janssen_diff", "ttau_diff", "GFAP_diff", "NFL_diff")] <- NA

calculate_and_store_diff <- function(data, baseline_col, followup_col, diff_col) {
  
    # Calculate the difference and update the existing diff column, dividing by days_diff
    data[[diff_col]] <- (data[[followup_col]] - data[[baseline_col]])
  
  return(data)
}



difference_cols <- c("Ab40_diff", "Ab42_40_ratio_diff", "Ab42_diff", 
                      "ptau181_diff", "ptau217_Lilly_diff", "ptau217_Janssen_diff", "ptau231_diff",
                       "ttau_diff", "GFAP_diff", "NFL_diff")

baseline_cols <- c("Ab40_plasmaF_SimoaNP4E_BL","Ab42_40_ratio_plasmaF_SimoaNP4E_BL",
"Ab42_plasmaF_SimoaNP4E_BL","ptau181_plasmaF_Simoa_BL", "ptau217_plasmaF_MSDLilly_BL", "ptau217_plasmaNF_SimoaJanssen_BL",    
"ptau231_plasmaF_SimoaGot_BL", "ttau_plasmaF_MSDLilly_BL", "GFAP_plasmaF_SimoaNP4E_BL", "NFL_plasmaF_SimoaNP4E_BL")

followup_cols <- c("Ab40_plasmaF_SimoaNP4E_FU","Ab42_40_ratio_plasmaF_SimoaNP4E_FU",
"Ab42_plasmaF_SimoaNP4E_FU","ptau181_plasmaF_Simoa_FU", "ptau217_plasmaF_MSDLilly_FU", "ptau217_plasmaNF_SimoaJanssen_FU",    
"ptau231_plasmaF_SimoaGot_FU", "ttau_plasmaF_MSDLilly_FU", "GFAP_plasmaF_SimoaNP4E_FU", "NFL_plasmaF_SimoaNP4E_FU")

covariates <- c("Age_V1S1", "Sex", "days_diff")

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  biomark_df <- calculate_and_store_diff(biomark_df, baseline_cols[i], followup_cols[i], difference_cols[i])
}

```


### Correction by covariates 

```{r}

# Multiple regression

# Regression against Age and Sex and Time
perform_mult_regression <- function(data, dependent_variable, covariates) {
  # Create a formula for regression
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  
  # Fit linear regression model
  model <- lm(formula, data = data, na.action = 'na.exclude')
  
  # Store the model in a list
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  
  return(result)
}

# Create an list to store the models
mult_models <-  vector("list", length = 10)

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(biomark_df, variable, covariates)
  
  # Store the model result in the list
  mult_models[[i]] <- model_result
}
```


### Calculate healthy groups means and sd

### PET reference group

```{r}
# Quantile 10
quantile(biomark_df$amyloid_PET_CL_BL_complete, probs = 0.10 , na.rm = TRUE) #-11.7253531

## Amyiloid group

# Create an empty list to store the results
residuals_amyloid_summary <- list()

# Loop through each model in the list
for (i in seq_along(mult_models)) {
  model <- mult_models[[i]]$model
  
  # Extract residuals for samples with amyloid_PET_CL_BL_complete < -11.7253531
  residuals_subset <- residuals(model)[biomark_df$amyloid_PET_CL_BL_complete < -11.7253531]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  residuals_amyloid_summary[[i]] <- list(
    model_name = mult_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  biomark_df[paste0("amyloid_mean_", mult_models[[i]]$dependent_variable)] <- residuals_mean
  biomark_df[paste0("amyloid_sd_", mult_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
amyloid_summary_df <- do.call(rbind, residuals_amyloid_summary)


```

### Calculate the z-scores from residuals and plot it

```{r}

# Function to compute z-scores for a list of models
compute_z_scores_PET <- function(model_list, data) {
  # Loop through each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
    # Check if the variable ends with "_diff"
    if (grepl("_diff$", variable)) {
      # Extract the residuals from the model
      residuals <- residuals(model)
      
      # Get mean and standard deviation from the corresponding columns in the data frame
      mean_col <- paste( "amyloid_mean_", variable, sep = "")
      sd_col <- paste( "amyloid_sd_", variable, sep = "")
      mean_val <- data[[mean_col]][1]
      sd_val <- data[[sd_col]][1]
      
      # Scale residuals by the mean and standard deviation
      z_scores <- scale(residuals, center = FALSE, scale = sd_val)
      
      # Create a new column in the data frame for the scaled z-scores
      z_score_col <- paste(variable, "_z_score_PET", sep = "")
      
      # Update the data frame with the z_scores
      data <- data %>%
      mutate(!!z_score_col := z_scores)
    }
  }
  
  return(data)
}

# Apply the function for each list of models
biomark_df <- compute_z_scores_PET(mult_models, biomark_df)

```



### Plot variables PET

```{r}
### Plot of z-scores against proxies

# Your list of z_score variables and proxy variables
z_score_PET <- c("Ab40_diff_z_score_PET", "Ab42_40_ratio_diff_z_score_PET", 
                  "Ab42_diff_z_score_PET", "ptau181_diff_z_score_PET", "ptau217_Lilly_diff_z_score_PET", "ptau217_Janssen_diff_z_score_PET", "ptau231_diff_z_score_PET", "ttau_diff_z_score_PET" ,
                  "GFAP_diff_z_score_PET", "NFL_diff_z_score_PET")

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_PET))



```

### Individual plots

```{r}



# Define the z_score variables and their corresponding colors
z_score_PET <- c("Ab40_diff_z_score_PET", "Ab42_40_ratio_diff_z_score_PET", "Ab42_diff_z_score_PET",
                 "ptau181_diff_z_score_PET", "ptau217_Lilly_diff_z_score_PET", "ptau217_Janssen_diff_z_score_PET",
                 "ptau231_diff_z_score_PET", "ttau_diff_z_score_PET", "GFAP_diff_z_score_PET", "NFL_diff_z_score_PET")

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create a data frame to store the response variable names
plot_PET <- data.frame(
  z_score_var = rep(z_score_PET, each = nrow(biomark_df)),
  amyloid_PET_CL_BL_complete = rep(biomark_df$amyloid_PET_CL_BL_complete, times = length(z_score_PET)),
  value = as.vector(sapply(z_score_PET, function(z_var) biomark_df[[z_var]]))
)

# Map z_score variables to biomarker names
plot_PET$biomarker_name <- factor(plot_PET$z_score_var, levels = z_score_PET, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET <- ggplot(plot_PET, aes(x = amyloid_PET_CL_BL_complete, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "Amyloid PET reference group",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y") +
  coord_cartesian(ylim = c(-4, 4))

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET)

# Print the interactive facet plot
print(interactive_facet_PET)



```

### Combined plot PET

```{r}
### Amyloid proxy one plot

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_PET, each = nrow(biomark_df)),
                        amyloid_PET_CL_BL_complete = rep(biomark_df$amyloid_PET_CL_BL_complete, times = length(z_score_PET)),
                        value = as.vector(sapply(z_score_PET, function(z_var) biomark_df[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = amyloid_PET_CL_BL_complete, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, se = TRUE, aes(fill = z_score_var), alpha = 0.1) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = -20, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Amyloid reference group using Amyloid PET BL as proxy",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_PET)) +
  theme_minimal() +
  coord_cartesian(ylim = c(-5,5))


# Convert ggplot to plotly plot
combined_amyloid <- ggplotly(combined_plot)

# Print the interactive plot
combined_amyloid


```


### Bootstrap Amyloid PET
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
biomark_df_complete <- biomark_df[complete.cases(biomark_df$amyloid_PET_CL_BL_complete), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_PET) {
  data <- biomark_df_complete[, c("amyloid_PET_CL_BL_complete", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ amyloid_PET_CL_BL_complete")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_PET) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_PET) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(biomark_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(biomark_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the amyloid_PET_CL_BL_complete column to averaged_predictions data frame
averaged_predictions$amyloid_PET_CL_BL_complete <- biomark_df_complete$amyloid_PET_CL_BL_complete


# List of variables to keep
variables_to_keep <- c(
  "amyloid_PET_CL_BL_complete",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))


```

### Bootstrap plots

```{r}


# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_PET", "Ab42_40_ratio_diff_z_score_PET", "Ab42_diff_z_score_PET",
                "ptau181_diff_z_score_PET", "ptau217_Lilly_diff_z_score_PET", "ptau217_Janssen_diff_z_score_PET",
                "ptau231_diff_z_score_PET", "ttau_diff_z_score_PET", "GFAP_diff_z_score_PET", "NFL_diff_z_score_PET")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = amyloid_PET_CL_BL_complete, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.2) +
    labs(x = "amyloid_PET_CL_BL_complete", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 12, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```





### CSF reference group
```{r}
## CSF group

ref_quantile <- quantile(biomark_df$ab42_40_ratio_CSFNC_BL, probs = 0.90, na.rm = TRUE)  #0.1004462

ref_quantile
# Create an empty list to store the results
residuals_CSF_summary <- list()

# Loop through each model in the list
for (i in seq_along(mult_models)) {
  model <- mult_models[[i]]$model
  
  # Extract residuals for samples with 
  residuals_subset <- residuals(model)[biomark_df$ab42_40_ratio_CSFNC_BL > 0.1]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  residuals_CSF_summary[[i]] <- list(
    model_name = mult_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  biomark_df[paste0("CSF_mean_", mult_models[[i]]$dependent_variable)] <- residuals_mean
  biomark_df[paste0("CSF_sd_", mult_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
CSF_summary_df <- do.call(rbind, residuals_CSF_summary)


```



### Calculate the z-scores from ab42_40_ratio_CSFNC_BL 

```{r}

# Function to compute z-scores for a list of models
compute_z_scores_CSF <- function(model_list, data) {
  # Loop through each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
    # Check if the variable ends with "_diff"
    if (grepl("_diff$", variable)) {
      # Extract the residuals from the model
      residuals <- residuals(model)
      
      # Get mean and standard deviation from the corresponding columns in the data frame
      mean_col <- paste( "CSF_mean_", variable, sep = "")
      sd_col <- paste( "CSF_sd_", variable, sep = "")
      mean_val <- data[[mean_col]][1]
      sd_val <- data[[sd_col]][1]
      
      # Scale residuals by the mean and standard deviation
      z_scores <- scale(residuals, center = FALSE, scale = sd_val)
      
      # Create a new column in the data frame for the scaled z-scores
      z_score_col <- paste(variable, "_z_score_CSF", sep = "")
      
      # Update the data frame with the z_scores
      data <- data %>%
      mutate(!!z_score_col := z_scores)
    }
  }
  
  return(data)
}

# Apply the function for each list of models
biomark_df <- compute_z_scores_CSF(mult_models, biomark_df)

```


### Plot variables CSF

```{r}
### Plot of z-scores against proxies

# Your list of z_score variables and proxy variables
z_score_CSF <- c("Ab40_diff_z_score_CSF", "Ab42_40_ratio_diff_z_score_CSF", 
                  "Ab42_diff_z_score_CSF", "ptau181_diff_z_score_CSF", "ptau217_Lilly_diff_z_score_CSF", "ptau217_Janssen_diff_z_score_CSF", "ptau231_diff_z_score_CSF", "ttau_diff_z_score_CSF" , "GFAP_diff_z_score_CSF", "NFL_diff_z_score_CSF")

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_CSF))

```

### Individual plots

```{r}
# Create a data frame to store the response variable names
plot_CSF <- data.frame(z_score_var = rep(z_score_CSF, each = nrow(biomark_df)),
                        ab42_40_ratio_CSFNC_BL = rep(biomark_df$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF)),
                        value = as.vector(sapply(z_score_CSF, function(z_var) biomark_df[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")


# Map z_score variables to biomarker names
plot_CSF$biomarker_name <- factor(plot_CSF$z_score_var, levels = z_score_CSF, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_plot <- ggplot(plot_CSF, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill =  biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "CSF reference group",
       x = "ab42_40_ratio_CSFNC_BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_x_continuous(trans = "reverse") + # Invert x-axis 
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to interactive plot using ggplotly
facet_CSF <- ggplotly(facet_plot)

# Print the interactive plot
print(facet_CSF)

```


### Combined plot

```{r}
# ab42_40_ratio_CSFNC_BL proxy 

# Combined plot

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_CSF, each = nrow(biomark_df)),
                        ab42_40_ratio_CSFNC_BL = rep(biomark_df$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF)),
                        value = as.vector(sapply(z_score_CSF, function(z_var) biomark_df[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 0.12, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "CSF reference group using CSF AB 42/40 ratio as proxy",
       x = "ab42/40 ratio CSFNC BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_CSF)) +
  theme_minimal() +
  scale_x_continuous(trans = "reverse")  # Invert x-axis

# Convert ggplot to interactive plot using ggplotly
combined_CSF <- ggplotly(combined_plot)

# Print the interactive plot
print(combined_CSF)


```


### Bootstrap CC CSF Ab 42/40
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
biomark_df_complete <- biomark_df[complete.cases(biomark_df$ab42_40_ratio_CSFNC_BL), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_CSF) {
  data <- biomark_df_complete[, c("ab42_40_ratio_CSFNC_BL", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ ab42_40_ratio_CSFNC_BL")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_CSF) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_CSF) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(biomark_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(biomark_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the ab42_40_ratio_CSFNC_BL column to averaged_predictions data frame
averaged_predictions$ab42_40_ratio_CSFNC_BL <- biomark_df_complete$ab42_40_ratio_CSFNC_BL


# List of variables to keep
variables_to_keep <- c(
  "ab42_40_ratio_CSFNC_BL",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_CSF", "Ab42_40_ratio_diff_z_score_CSF", 
                  "Ab42_diff_z_score_CSF", "ptau181_diff_z_score_CSF", "ptau217_Lilly_diff_z_score_CSF", "ptau217_Janssen_diff_z_score_CSF", "ptau231_diff_z_score_CSF", "ttau_diff_z_score_CSF" , "GFAP_diff_z_score_CSF", "NFL_diff_z_score_CSF")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = ab42_40_ratio_CSFNC_BL, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "ab42_40_ratio_CSFNC_BL", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 0.071, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name)) +
    scale_x_continuous(trans = "reverse")
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```



### Age as proxy


```{r}

## Linear regression

# Regression against Sex
perform_mult_regression <- function(data, dependent_variable, covariates) {
  # Create a formula for regression
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  
  # Fit linear regression model
  model <- lm(formula, data = data, na.action = 'na.exclude')
  
  # Store the model in a list
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  
  return(result)
}

covariates <- c("Sex","days_diff")

# Create an list to store the models
age_models <- vector("list", length = 10)

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(biomark_df, variable, covariates)
  
  # Store the model result in the list
  age_models[[i]] <- model_result
}

```



```{r}
## Quantile 10
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31

# Create an empty list to store the results
age_residuals_summary <- list()

# Loop through each model in the list
for (i in seq_along(age_models)) {
  model <- age_models[[i]]$model
  
  # Extract residuals for samples with amyloid_PET_CL_BL_complete <= 54.31
  residuals_subset <- residuals(model)[biomark_df$Age_V1S1 < 54.31]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  age_residuals_summary[[i]] <- list(
    model_name = age_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  biomark_df[paste0("age_residuals_mean_", age_models[[i]]$dependent_variable)] <- residuals_mean
  biomark_df[paste0("age_residuals_sd_", age_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
age_residuals_df <- do.call(rbind, age_residuals_summary)
```

```{r}
# Function to compute z-scores for a list of models
compute_z_scores_Age <- function(model_list, data) {
  # Loop through each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
      # Extract the residuals from the model
      residuals <- residuals(model)
      
      # Get mean and standard deviation from the corresponding columns in the data frame
      mean_col <- paste("age_residuals_mean_", variable, sep = "")
      sd_col <- paste( "age_residuals_sd_", variable, sep = "")
      mean_val <- data[[mean_col]][1]
      sd_val <- data[[sd_col]][1]
      
      # Scale residuals by the mean and standard deviation
      z_scores <- scale(residuals, center = FALSE, scale = sd_val)
      
      # Create a new column in the data frame for the scaled z-scores
      z_score_col <- paste(variable, "_z_score_Age", sep = "")
      
      # Update the data frame with the z_scores
      data <- data %>%
      mutate(!!z_score_col := z_scores)
    
  }
  
  return(data)
}

# Apply the function for each list of models
biomark_df <- compute_z_scores_Age(age_models, biomark_df)

### Plot of PET amyloid z-scores against proxies

# Your list of z_score variables and proxy variables
z_score_Age <- c("Ab40_diff_z_score_Age", "Ab42_40_ratio_diff_z_score_Age",
                 "Ab42_diff_z_score_Age", "ptau181_diff_z_score_Age", 
                 "ptau231_diff_z_score_Age", "ptau217_Lilly_diff_z_score_Age",          "ptau217_Janssen_diff_z_score_Age", "ttau_diff_z_score_Age", "GFAP_diff_z_score_Age",                 "NFL_diff_z_score_Age")

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_Age))


```

### Individual plots AGE
```{r}
# Create a data frame to store the response variable names
plot_AGE <- data.frame(z_score_var = rep(z_score_Age, each = nrow(biomark_df)),
                        Age_V1S1 = rep(biomark_df$Age_V1S1, times = length(z_score_Age)),
                        value = as.vector(sapply(z_score_Age, function(z_var) biomark_df[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_AGE$biomarker_name <- factor(plot_AGE$z_score_var, levels = z_score_Age, labels = biomarker_names)


# Plot ggplot with loess smoothing for each z_score variable
facet_AGE <- ggplot(plot_AGE, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.4, color = 'red') +
  labs(title = "Age reference group",
       x = "Age_V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y") +
  coord_cartesian(xlim = c(47,75))

# Convert ggplot to interactive plot using ggplotly
intercative_plotly_AGE <- ggplotly(facet_AGE)

# Print the interactive plot
print(intercative_plotly_AGE)


```


```{r}
## Combined plots

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_Age, each = nrow(biomark_df)),
                        Age_V1S1 = rep(biomark_df$Age_V1S1, times = length(z_score_Age)),
                        value = as.vector(sapply(z_score_Age, function(z_var) biomark_df[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = Age_V1S1, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 54.31, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 50, y = 2.1, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Age reference group using age as proxy",
       x = "Age V1S1",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(color_palette, z_score_Age)) +
  theme_minimal()

# Convert ggplot to plotly plot
combined_amyloid_age <- ggplotly(combined_plot)

# Print the interactive plot
combined_amyloid_age
```



### Bootstrap AGE
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
biomark_df_complete <- biomark_df[complete.cases(biomark_df$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_Age) {
  data <- biomark_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_Age) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_Age) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(biomark_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(biomark_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- biomark_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- z_score_Age <- c("Ab40_diff_z_score_Age", "Ab42_40_ratio_diff_z_score_Age",
                 "Ab42_diff_z_score_Age", "ptau181_diff_z_score_Age", 
                 "ptau231_diff_z_score_Age", "ptau217_Lilly_diff_z_score_Age","ptau217_Janssen_diff_z_score_Age", "ttau_diff_z_score_Age", "GFAP_diff_z_score_Age", "NFL_diff_z_score_Age")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```



### Sex stratification

```{r}

# Sex subset

male <- biomark_df[biomark_df$Sex == 1, ]

female <- biomark_df[biomark_df$Sex == 2, ]

### Baseline

## Multiple regression

# Regression against Age 
perform_mult_regression <- function(data, dependent_variable, covariates) {
  # Create a formula for regression
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  
  # Fit linear regression model
  model <- lm(formula, data = data, na.action = 'na.exclude')
  
  # Store the model in a list
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  
  return(result)
}

covariates <- c("Age_V1S1", "days_diff")

# Male model

male_models <- vector("list", length = 10)

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(male, variable, covariates)
  
  # Store the model result in the list
  male_models[[i]] <- model_result
}


# Female model

female_models <- vector("list", length = 10)

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(female, variable, covariates)
  
  # Store the model result in the list
  female_models[[i]] <- model_result
}

```


### Male Reference groups

```{r}

# Quantile 10
quantile(biomark_df$amyloid_PET_CL_BL_complete, probs = 0.10, na.rm = TRUE) #-11.72535 
# Quantile 90
quantile(biomark_df$ab42_40_ratio_CSFNC_BL, probs = 0.90, na.rm = TRUE) #0.09721704 

# Male reference groups

# Amyiloid group

# Create an empty list to store the results
residuals_amyloid_male <- list()

# Loop through each model in the list
for (i in seq_along(male_models)) {
  model <- male_models[[i]]$model
  
  # Extract residuals for samples with amyloid_PET_CL_BL_complete quantile
  residuals_subset <- residuals(model)[male$amyloid_PET_CL_BL_complete < -11.72535]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  residuals_amyloid_male[[i]] <- list(
    model_name = male_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  male[paste0("amyloid_mean_", male_models[[i]]$dependent_variable)] <- residuals_mean
  male[paste0("amyloid_sd_", male_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
amyloid_male_df <- do.call(rbind, residuals_amyloid_male)


## CSF group

# Create an empty list to store the results
residuals_CSF_male <- list()

# Loop through each model in the list
for (i in seq_along(male_models)) {
  model <- male_models[[i]]$model
  
  # Extract residuals for samples with ab42_40_ratio_CSFNC_BL > 0.09721704
  residuals_subset <- residuals(model)[male$ab42_40_ratio_CSFNC_BL > 0.09721704]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  residuals_CSF_male[[i]] <- list(
    model_name = male_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  male[paste0("CSF_mean_", male_models[[i]]$dependent_variable)] <- residuals_mean
  male[paste0("CSF_sd_", male_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
CSF_male_df <- do.call(rbind, residuals_CSF_male)



```


# Female reference groups

```{r}


# Female reference groups

## Quantile 10
quantile(biomark_df$amyloid_PET_CL_BL_complete, probs = 0.10, na.rm = TRUE)
#-11.72535
## Quantile 90
quantile(biomark_df$ab42_40_ratio_CSFNC_BL, probs = 0.90, na.rm = TRUE)
#0.09721704 

## Amyiloid group

# Create an empty list to store the results
residuals_amyloid_female <- list()

# Loop through each model in the list
for (i in seq_along(female_models)) {
  model <- female_models[[i]]$model
  
  # Extract residuals for samples with amyloid_PET_CL_BL_complete < -12.68021
  residuals_subset <- residuals(model)[female$amyloid_PET_CL_BL_complete < -11.72535]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  residuals_amyloid_female[[i]] <- list(
    model_name = female_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  female[paste0("amyloid_mean_", female_models[[i]]$dependent_variable)] <- residuals_mean
  female[paste0("amyloid_sd_", female_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
amyloid_female_df <- do.call(rbind, residuals_amyloid_female)


## CSF group

# Create an empty list to store the results
residuals_CSF_female <- list()

# Loop through each model in the list
for (i in seq_along(female_models)) {
  model <- female_models[[i]]$model
  
  # Extract residuals for samples with ab42_40_ratio_CSFNC_BL > 0.09859299
  residuals_subset <- residuals(model)[female$ab42_40_ratio_CSFNC_BL > 0.09721704]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  residuals_CSF_female[[i]] <- list(
    model_name = female_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  female[paste0("CSF_mean_", female_models[[i]]$dependent_variable)] <- residuals_mean
  female[paste0("CSF_sd_", female_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
CSF_female_df <- do.call(rbind, residuals_CSF_female)

```

### Z-scores for Amiloid PET reference group

```{r}
# Function to compute z-scores for a list of models
compute_z_scores_PET <- function(model_list, data) {
  # Loop through each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
      # Extract the residuals from the model
      residuals <- residuals(model)
      
      # Get mean and standard deviation from the corresponding columns in the data frame
      mean_col <- paste("amyloid_mean_", variable, sep = "")
      sd_col <- paste( "amyloid_sd_", variable, sep = "")
      mean_val <- data[[mean_col]][1]
      sd_val <- data[[sd_col]][1]
      
      # Scale residuals by the mean and standard deviation
      z_scores <- scale(residuals, center = FALSE, scale = sd_val)
      
      # Create a new column in the data frame for the scaled z-scores
      z_score_col <- paste(variable, "_z_score_PET", sep = "")
      
      # Update the data frame with the z_scores
      data <- data %>%
      mutate(!!z_score_col := z_scores)
    
  }
  
  return(data)
}

# Z-scores for male subset
male <- compute_z_scores_PET(male_models, male)
female <- compute_z_scores_PET(female_models, female)

### Plot of PET amyloid z-scores against proxies

# Your list of z_score variables and proxy variables
z_score_PET <- c("Ab40_diff_z_score_PET", "Ab42_40_ratio_diff_z_score_PET", "Ab42_diff_z_score_PET", "ptau181_diff_z_score_PET", "ptau231_diff_z_score_PET", "ptau217_Lilly_diff_z_score_PET", "ptau217_Janssen_diff_z_score_PET", "ttau_diff_z_score_PET", "GFAP_diff_z_score_PET", "NFL_diff_z_score_PET")

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_PET))


```

### Amyloid PET reference group for males individual plots
```{r}

# Create a data frame to store the response variable names
plot_PET <- data.frame(z_score_var = rep(z_score_PET, each = nrow(male)),
                        amyloid_PET_CL_BL_complete = rep(male$amyloid_PET_CL_BL_complete, times = length(z_score_PET)),
                        value = as.vector(sapply(z_score_PET, function(z_var) male[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_PET$biomarker_name <- factor(plot_PET$z_score_var, levels = z_score_PET, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET <- ggplot(plot_PET, aes(x = amyloid_PET_CL_BL_complete, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "Amyloid PET reference group in male",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET)

# Print the interactive facet plot
print(interactive_facet_PET)

```

### Male

### Combined biomarkers plot
```{r}
## Combined plots

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_PET, each = nrow(male)),
                        amyloid_PET_CL_BL_complete = rep(male$amyloid_PET_CL_BL_complete, times = length(z_score_PET)),
                        value = as.vector(sapply(z_score_PET, function(z_var) male[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = amyloid_PET_CL_BL_complete, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = -10, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Amyloid reference group in males ",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_PET)) +
  theme_minimal()

# Convert ggplot to plotly plot
combined_amyloid <- ggplotly(combined_plot)

# Print the interactive plot
combined_amyloid

```


### Bootstrap Amyloid PET Male
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
male_df_complete <- male[complete.cases(male$amyloid_PET_CL_BL_complete), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_PET) {
  data <- male_df_complete[, c("amyloid_PET_CL_BL_complete", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ amyloid_PET_CL_BL_complete")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_PET) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_PET) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(male_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(male_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the amyloid_PET_CL_BL_complete column to averaged_predictions data frame
averaged_predictions$amyloid_PET_CL_BL_complete <- male_df_complete$amyloid_PET_CL_BL_complete


# List of variables to keep
variables_to_keep <- c(
  "amyloid_PET_CL_BL_complete",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Plots Bootstrap amyloid PET male
```{r}
# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_PET", "Ab42_40_ratio_diff_z_score_PET", "Ab42_diff_z_score_PET",
                "ptau181_diff_z_score_PET", "ptau217_Lilly_diff_z_score_PET", "ptau217_Janssen_diff_z_score_PET",
                "ptau231_diff_z_score_PET", "ttau_diff_z_score_PET", "GFAP_diff_z_score_PET", "NFL_diff_z_score_PET")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = amyloid_PET_CL_BL_complete, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "amyloid_PET_CL_BL_complete", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 12, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)
```


### Individual female plots
```{r}
### Amyloid proxy different plots

# Create a data frame to store the response variable names
plot_PET <- data.frame(z_score_var = rep(z_score_PET, each = nrow(female)),
                        amyloid_PET_CL_BL_complete = rep(female$amyloid_PET_CL_BL_complete, times = length(z_score_PET)),
                        value = as.vector(sapply(z_score_PET, function(z_var) female[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_PET$biomarker_name <- factor(plot_PET$z_score_var, levels = z_score_PET, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET <- ggplot(plot_PET, aes(x = amyloid_PET_CL_BL_complete, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "Amyloid reference group in female",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET)

# Print the interactive facet plot
print(interactive_facet_PET)
```


### Combined biomarkers plot
```{r}
## Combined plots

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_PET, each = nrow(female)),
                        amyloid_PET_CL_BL_complete = rep(female$amyloid_PET_CL_BL_complete, times = length(z_score_PET)),
                        value = as.vector(sapply(z_score_PET, function(z_var) female[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = amyloid_PET_CL_BL_complete, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = -10, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Amyloid reference group in females ",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_PET)) +
  theme_minimal()

# Convert ggplot to plotly plot
combined_amyloid <- ggplotly(combined_plot)

# Print the interactive plot
combined_amyloid

```


### Bootstrap Amyloid PET Female
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
female_df_complete <- female[complete.cases(female$amyloid_PET_CL_BL_complete), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_PET) {
  data <- female_df_complete[, c("amyloid_PET_CL_BL_complete", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ amyloid_PET_CL_BL_complete")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_PET) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_PET) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(female_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(female_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the amyloid_PET_CL_BL_complete column to averaged_predictions data frame
averaged_predictions$amyloid_PET_CL_BL_complete <- female_df_complete$amyloid_PET_CL_BL_complete


# List of variables to keep
variables_to_keep <- c(
  "amyloid_PET_CL_BL_complete",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```



### Plots Bootstrap amyloid PET female
```{r}
# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_PET", "Ab42_40_ratio_diff_z_score_PET", "Ab42_diff_z_score_PET",
                "ptau181_diff_z_score_PET", "ptau217_Lilly_diff_z_score_PET", "ptau217_Janssen_diff_z_score_PET",
                "ptau231_diff_z_score_PET", "ttau_diff_z_score_PET", "GFAP_diff_z_score_PET", "NFL_diff_z_score_PET")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = amyloid_PET_CL_BL_complete, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "amyloid_PET_CL_BL_complete", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 12, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)
```



### Compute z-scores using CSF AB 42/40 ratio reference group

```{r}
# Function to compute z-scores for a list of models
compute_z_scores_CSF <- function(model_list, data) {
  # Loop through each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
      # Extract the residuals from the model
      residuals <- residuals(model)
      
      # Get mean and standard deviation from the corresponding columns in the data frame
      mean_col <- paste("CSF_mean_", variable, sep = "")
      sd_col <- paste( "CSF_sd_", variable, sep = "")
      mean_val <- data[[mean_col]][1]
      sd_val <- data[[sd_col]][1]
      
      # Scale residuals by the mean and standard deviation
      z_scores <- scale(residuals, center = FALSE, scale = sd_val)
      
      # Create a new column in the data frame for the scaled z-scores
      z_score_col <- paste(variable, "_z_score_CSF", sep = "")
      
      # Update the data frame with the z_scores
      data <- data %>%
      mutate(!!z_score_col := z_scores)
    
  }
  
  return(data)
}

# Apply the function for each list of models
# Z-scores for male subset
male <- compute_z_scores_CSF(male_models, male)
female <- compute_z_scores_CSF(female_models, female)

# List of CSF z_score variables
z_score_CSF <- c("Ab40_diff_z_score_CSF", "Ab42_40_ratio_diff_z_score_CSF", 
                  "Ab42_diff_z_score_CSF", "ptau181_diff_z_score_CSF", "ptau217_Lilly_diff_z_score_CSF", "ptau217_Janssen_diff_z_score_CSF", "ptau231_diff_z_score_CSF", "ttau_diff_z_score_CSF" , "GFAP_diff_z_score_CSF", "NFL_diff_z_score_CSF")

# Color palette for z_score variables
color_palette <- rainbow(length(z_score_CSF))


```

### Male

### Individual plots
```{r}

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_CSF, each = nrow(male)),
                        ab42_40_ratio_CSFNC_BL = rep(male$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF)),
                        value = as.vector(sapply(z_score_CSF, function(z_var) male[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_data$biomarker_name <- factor(plot_data$z_score_var, levels = z_score_CSF, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET <- ggplot(plot_data, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
 geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "CSF reference group in male",
       x = "ab42_40_ratio_CSFNC_BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
   scale_x_continuous(trans = "reverse") +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET)

# Print the interactive facet plot
print(interactive_facet_PET)

```


### Combined biomarkers plot
```{r}
### Combined plot

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_CSF, each = nrow(male)),
                        ab42_40_ratio_CSFNC_BL = rep(male$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF)),
                        value = as.vector(sapply(z_score_CSF, function(z_var) male[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 0, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "CSF reference group in males",
      x = "ab42/40 ratio CSFNC BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_CSF)) +
  theme_minimal() +
  scale_x_continuous(trans = "reverse")

# Convert ggplot to interactive plot using ggplotly
combined_CSF <- ggplotly(combined_plot)

# Print the interactive plot
print(combined_CSF)


```



### Bootstrap CC CSF Ab 42/40 for Males
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
male_df_complete <- male[complete.cases(male$ab42_40_ratio_CSFNC_BL), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_CSF) {
  data <- male_df_complete[, c("ab42_40_ratio_CSFNC_BL", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ ab42_40_ratio_CSFNC_BL")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_CSF) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_CSF) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(male_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(male_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the ab42_40_ratio_CSFNC_BL column to averaged_predictions data frame
averaged_predictions$ab42_40_ratio_CSFNC_BL <- male_df_complete$ab42_40_ratio_CSFNC_BL


# List of variables to keep
variables_to_keep <- c(
  "ab42_40_ratio_CSFNC_BL",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```


```{r}

# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_CSF", "Ab42_40_ratio_diff_z_score_CSF", 
                  "Ab42_diff_z_score_CSF", "ptau181_diff_z_score_CSF", "ptau217_Lilly_diff_z_score_CSF", "ptau217_Janssen_diff_z_score_CSF", "ptau231_diff_z_score_CSF", "ttau_diff_z_score_CSF" , "GFAP_diff_z_score_CSF", "NFL_diff_z_score_CSF")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = ab42_40_ratio_CSFNC_BL, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "ab42_40_ratio_CSFNC_BL", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 0.071, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name)) +
    scale_x_continuous(trans = "reverse")
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```



### Female

### Individual plots
```{r}

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_CSF, each = nrow(female)),
                        ab42_40_ratio_CSFNC_BL = rep(female$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF)),
                        value = as.vector(sapply(z_score_CSF, function(z_var) female[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_data$biomarker_name <- factor(plot_data$z_score_var, levels = z_score_CSF, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET <- ggplot(plot_data, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
 geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "CSF reference group in female",
       x = "ab42_40_ratio_CSFNC_BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_x_continuous(trans = "reverse") +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET)

# Print the interactive facet plot
print(interactive_facet_PET)
```


### Combined biomarkers plot
```{r}
### Combined plot

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_CSF, each = nrow(female)),
                        ab42_40_ratio_CSFNC_BL = rep(female$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF)),
                        value = as.vector(sapply(z_score_CSF, function(z_var) female[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 0.1, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "CSF AB 42/40 reference group in females",
       x = "ab42/40 ratio CSFNC BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_CSF)) +
  theme_minimal() +
  scale_x_continuous(trans = "reverse")

# Convert ggplot to interactive plot using ggplotly
combined_CSF <- ggplotly(combined_plot)

# Print the interactive plot
print(combined_CSF)

```



### Bootstrap CC CSF Ab 42/40 for Females
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
female_df_complete <- female[complete.cases(female$ab42_40_ratio_CSFNC_BL), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_CSF) {
  data <- female_df_complete[, c("ab42_40_ratio_CSFNC_BL", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ ab42_40_ratio_CSFNC_BL")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_CSF) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_CSF) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(female_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(female_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the ab42_40_ratio_CSFNC_BL column to averaged_predictions data frame
averaged_predictions$ab42_40_ratio_CSFNC_BL <- female_df_complete$ab42_40_ratio_CSFNC_BL


# List of variables to keep
variables_to_keep <- c(
  "ab42_40_ratio_CSFNC_BL",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_CSF", "Ab42_40_ratio_diff_z_score_CSF", 
                  "Ab42_diff_z_score_CSF", "ptau181_diff_z_score_CSF", "ptau217_Lilly_diff_z_score_CSF", "ptau217_Janssen_diff_z_score_CSF", "ptau231_diff_z_score_CSF", "ttau_diff_z_score_CSF" , "GFAP_diff_z_score_CSF", "NFL_diff_z_score_CSF")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = ab42_40_ratio_CSFNC_BL, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "ab42_40_ratio_CSFNC_BL", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 0.071, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name)) +
    scale_x_continuous(trans = "reverse")
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```


### Sex stratification and Age as proxy

```{r}

male <- biomark_df[biomark_df$Sex == 1, ]

female <- biomark_df[biomark_df$Sex == 2, ]

```

### Age as proxy

```{r}

## Linear regression

# Regression against days_diff
perform_mult_regression <- function(data, dependent_variable, covariates) {
  # Create a formula for regression
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  
  # Fit linear regression model
  model <- lm(formula, data = data, na.action = 'na.exclude')
  
  # Store the model in a list
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  
  return(result)
}

covariates <- "days_diff"

# Male

# Create an list to store the models
ageSex_male_models <- vector("list", length = 10)

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(male, variable, covariates)
  
  # Store the model result in the list
  ageSex_male_models[[i]] <- model_result
}

# Female

# Create an list to store the models
ageSex_female_models <- vector("list", length = 10)

# Apply the function for each variable in difference_cols
for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(female, variable, covariates)
  
  # Store the model result in the list
  ageSex_female_models[[i]] <- model_result
}


```


### Male
```{r}
## Quantile 10
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31

# Create an empty list to store the results
age_male_residuals_summary <- list()

# Loop through each model in the list
for (i in seq_along(ageSex_male_models)) {
  model <- ageSex_male_models[[i]]$model
  
  # Extract residuals for samples with amyloid_PET_CL_BL_complete <= 54.31
  residuals_subset <- residuals(model)[male$Age_V1S1 < 54.31]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  age_male_residuals_summary[[i]] <- list(
    model_name = ageSex_male_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  male[paste0("age_sex_residuals_mean_", ageSex_male_models[[i]]$dependent_variable)] <- residuals_mean
  male[paste0("age_sex_residuals_sd_", ageSex_male_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
age_male_residuals_df <- do.call(rbind, age_male_residuals_summary)
```


### Female
```{r}
## Quantile 10
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31

# Create an empty list to store the results
age_female_residuals_summary <- list()

# Loop through each model in the list
for (i in seq_along(ageSex_female_models)) {
  model <- ageSex_female_models[[i]]$model
  
  # Extract residuals for samples with amyloid_PET_CL_BL_complete <= 54.31
  residuals_subset <- residuals(model)[female$Age_V1S1 < 54.31]
  
  # Calculate mean and standard deviation of residuals subset
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  # Store the mean and sd in the results list
  age_female_residuals_summary[[i]] <- list(
    model_name = ageSex_female_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  
  # Add mean and sd as new columns in biomark_df
  female[paste0("age_sex_residuals_mean_", ageSex_female_models[[i]]$dependent_variable)] <- residuals_mean
  female[paste0("age_sex_residuals_sd_", ageSex_female_models[[i]]$dependent_variable)] <- residuals_sd
}

# Convert the results list to a data frame
age_female_residuals_df <- do.call(rbind, age_female_residuals_summary)
```


```{r}
# Function to compute z-scores for a list of models
compute_z_scores_Age_sex <- function(model_list, data) {
  # Loop through each model in the list
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
      # Extract the residuals from the model
      residuals <- residuals(model)
      
      # Get mean and standard deviation from the corresponding columns in the data frame
      mean_col <- paste("age_sex_residuals_mean_", variable, sep = "")
      sd_col <- paste( "age_sex_residuals_sd_", variable, sep = "")
      mean_val <- data[[mean_col]][1]
      sd_val <- data[[sd_col]][1]
      
      # Scale residuals by the mean and standard deviation
      z_scores <- scale(residuals, center = FALSE, scale = sd_val)
      
      # Create a new column in the data frame for the scaled z-scores
      z_score_col <- paste(variable, "_z_score_Age_Sex", sep = "")
      
      # Update the data frame with the z_scores
      data <- data %>%
      mutate(!!z_score_col := z_scores)
    
  }
  
  return(data)
}

# Apply the function for each list of models
male <- compute_z_scores_Age_sex(ageSex_male_models, male)
female <- compute_z_scores_Age_sex(ageSex_female_models, female)


# Your list of z_score variables and proxy variables
z_score_Age_Sex <- c("Ab40_diff_z_score_Age_Sex", "Ab42_40_ratio_diff_z_score_Age_Sex",
                 "Ab42_diff_z_score_Age_Sex", "ptau181_diff_z_score_Age_Sex", 
                 "ptau231_diff_z_score_Age_Sex", "ptau217_Lilly_diff_z_score_Age_Sex","ptau217_Janssen_diff_z_score_Age_Sex", "ttau_diff_z_score_Age_Sex", "GFAP_diff_z_score_Age_Sex", "NFL_diff_z_score_Age_Sex")

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_Age_Sex))


```

### Male

### Individual plots
```{r}
# Create a data frame
plot_AgeSex <- data.frame(z_score_var = rep(z_score_Age_Sex, each = nrow(male)),
                        Age_V1S1 = rep(male$Age_V1S1, times = length(z_score_Age_Sex)),
                        value = as.vector(sapply(z_score_Age_Sex, function(z_var) male[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_AgeSex$biomarker_name <- factor(plot_AgeSex$z_score_var, levels = z_score_Age_Sex, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_plot <- ggplot(plot_AgeSex, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  labs(title = "Age reference group in male",
       x = "Age_V1S1",
       y = "Raw values") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to interactive plot using ggplotly
facet_Age <- ggplotly(facet_plot)

# Print the interactive plot
print(facet_Age)
```



### Combined plots
```{r}

# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_Age_Sex, each = nrow(male)),
                        Age_V1S1 = rep(male$Age_V1S1, times = length(z_score_Age_Sex)),
                        value = as.vector(sapply(z_score_Age_Sex, function(z_var) male[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = Age_V1S1, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +
  labs(title = "Age reference group in males ",
       x = "Age",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_Age_Sex)) +
  theme_minimal() # Setting x-axis limits

# Convert ggplot to plotly plot
combined_amyloid_age <- ggplotly(combined_plot)

# Print the interactive plot
combined_amyloid_age

```


### Bootstrap AGE and SEX Males
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
male_df_complete <- male[complete.cases(male$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_Age_Sex) {
  data <- male_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_Age_Sex) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_Age_Sex) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(male_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(male_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- male_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```


### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- z_score_Age_Sex <- c("Ab40_diff_z_score_Age_Sex", "Ab42_40_ratio_diff_z_score_Age_Sex",
                 "Ab42_diff_z_score_Age_Sex", "ptau181_diff_z_score_Age_Sex", 
                 "ptau231_diff_z_score_Age_Sex", "ptau217_Lilly_diff_z_score_Age_Sex","ptau217_Janssen_diff_z_score_Age_Sex", "ttau_diff_z_score_Age_Sex", "GFAP_diff_z_score_Age_Sex", "NFL_diff_z_score_Age_Sex")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```

### Female 

### Individual plots

```{r}
# Create a data frame
plot_AgeSex <- data.frame(z_score_var = rep(z_score_Age_Sex, each = nrow(female)),
                        Age_V1S1 = rep(female$Age_V1S1, times = length(z_score_Age_Sex)),
                        value = as.vector(sapply(z_score_Age_Sex, function(z_var) female[[z_var]])))

biomarker_colors <- c("#F8766D", "#A3A500", "#D89000", "#00BFC4", "#00B0F6", "#9590FF",
                      "#E76BF3", "#FF62BC", "#39B600", "#00BF7D")

# Named vector of biomarkers for legends.
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Map z_score variables to biomarker names
plot_AgeSex$biomarker_name <- factor(plot_AgeSex$z_score_var, levels = z_score_Age_Sex, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_plot <- ggplot(plot_AgeSex, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 54.09, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "Age reference group in female",
       x = "Age_V1S1",
       y = "Raw values") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to interactive plot using ggplotly
facet_Age <- ggplotly(facet_plot)

# Print the interactive plot
print(facet_Age)

```


### Combined plots
```{r}


# Create a data frame to store the response variable names
plot_data <- data.frame(z_score_var = rep(z_score_Age_Sex, each = nrow(female)),
                        Age_V1S1 = rep(female$Age_V1S1, times = length(z_score_Age_Sex)),
                        value = as.vector(sapply(z_score_Age_Sex, function(z_var) female[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable
combined_plot <- ggplot(plot_data, aes(x = Age_V1S1, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +
  labs(title = "Age reference group in females",
       x = "Age V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_Age_Sex)) +
  theme_minimal()

# Convert ggplot to plotly plot
combined_amyloid_age <- ggplotly(combined_plot)

# Print the interactive plot
combined_amyloid_age

```


### Bootstrap AGE and SEX Females
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
female_df_complete <- female[complete.cases(female$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_Age_Sex) {
  data <- female_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_Age_Sex) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_Age_Sex) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(female_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(female_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- female_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- z_score_Age_Sex <- c("Ab40_diff_z_score_Age_Sex", "Ab42_40_ratio_diff_z_score_Age_Sex",
                 "Ab42_diff_z_score_Age_Sex", "ptau181_diff_z_score_Age_Sex", 
                 "ptau231_diff_z_score_Age_Sex", "ptau217_Lilly_diff_z_score_Age_Sex","ptau217_Janssen_diff_z_score_Age_Sex", "ttau_diff_z_score_Age_Sex", "GFAP_diff_z_score_Age_Sex", "NFL_diff_z_score_Age_Sex")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```


### APOE Carriership


```{r}
# APOE_binary subset
carrier <- biomark_df[biomark_df$APOE_binary == 1, ]
non_carrier <- biomark_df[biomark_df$APOE_binary == 0, ]

# Baseline

# Multiple regression

# Function for multiple regression
perform_mult_regression <- function(data, dependent_variable, covariates) {
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  model <- lm(formula, data = data, na.action = 'na.exclude')
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  return(result)
}

covariates <- c("Age_V1S1", "Sex")

# Carrier model
carrier_models <- vector("list", length = 10)

for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(carrier, variable, covariates)
  carrier_models[[i]] <- model_result
}

# Non-carrier model
non_carrier_models <- vector("list", length = 10)

for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(non_carrier, variable, covariates)
  non_carrier_models[[i]] <- model_result
}

```


### Reference groups


```{r}
# Reference groups

## Carrier quantiles
quantile(biomark_df$amyloid_PET_CL_BL_complete, probs = 0.10, na.rm = TRUE) # -11.72535 
quantile(biomark_df$ab42_40_ratio_CSFNC_BL, probs = 0.90, na.rm = TRUE) # 0.09721704


## Non-carrier quantiles
quantile(biomark_df$amyloid_PET_CL_BL_complete, probs = 0.10, na.rm = TRUE) # -11.72535 
quantile(biomark_df$ab42_40_ratio_CSFNC_BL, probs = 0.95, na.rm = TRUE) # 0.09721704

# Carrier reference groups

# Amyloid group
residuals_amyloid_carrier <- list()
for (i in seq_along(carrier_models)) {
  model <- carrier_models[[i]]$model
  residuals_subset <- residuals(model)[carrier$amyloid_PET_CL_BL_complete < -11.72535]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  residuals_amyloid_carrier[[i]] <- list(
    model_name = carrier_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  carrier[paste0("amyloid_mean_", carrier_models[[i]]$dependent_variable)] <- residuals_mean
  carrier[paste0("amyloid_sd_", carrier_models[[i]]$dependent_variable)] <- residuals_sd
}
amyloid_carrier_df <- do.call(rbind, residuals_amyloid_carrier)

# CSF group
residuals_CSF_carrier <- list()
for (i in seq_along(carrier_models)) {
  model <- carrier_models[[i]]$model
  residuals_subset <- residuals(model)[carrier$ab42_40_ratio_CSFNC_BL > 0.09721704]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  residuals_CSF_carrier[[i]] <- list(
    model_name = carrier_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  carrier[paste0("CSF_mean_", carrier_models[[i]]$dependent_variable)] <- residuals_mean
  carrier[paste0("CSF_sd_", carrier_models[[i]]$dependent_variable)] <- residuals_sd
}
CSF_carrier_df <- do.call(rbind, residuals_CSF_carrier)


# Non-carrier reference groups

# Amyloid group
residuals_amyloid_non_carrier <- list()
for (i in seq_along(non_carrier_models)) {
  model <- non_carrier_models[[i]]$model
  residuals_subset <- residuals(model)[non_carrier$amyloid_PET_CL_BL_complete < -11.72535]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  residuals_amyloid_non_carrier[[i]] <- list(
    model_name = non_carrier_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  non_carrier[paste0("amyloid_mean_", non_carrier_models[[i]]$dependent_variable)] <- residuals_mean
  non_carrier[paste0("amyloid_sd_", non_carrier_models[[i]]$dependent_variable)] <- residuals_sd
}
amyloid_non_carrier_df <- do.call(rbind, residuals_amyloid_non_carrier)

# CSF group
residuals_CSF_non_carrier <- list()
for (i in seq_along(non_carrier_models)) {
  model <- non_carrier_models[[i]]$model
  residuals_subset <- residuals(model)[non_carrier$ab42_40_ratio_CSFNC_BL > 0.09721704]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  residuals_CSF_non_carrier[[i]] <- list(
    model_name = non_carrier_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  non_carrier[paste0("CSF_mean_", non_carrier_models[[i]]$dependent_variable)] <- residuals_mean
  non_carrier[paste0("CSF_sd_", non_carrier_models[[i]]$dependent_variable)] <- residuals_sd
}
CSF_non_carrier_df <- do.call(rbind, residuals_CSF_non_carrier)

```


### Amyloid Z-scores

```{r}
# Function to compute z-scores for a list of models based on APOE_binary
compute_z_scores_PET_APOE <- function(model_list, data) {
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
    residuals <- residuals(model)
    
    # Get mean and standard deviation from the corresponding columns in the data frame based on APOE_binary
    mean_col <- paste("amyloid_mean_", variable, sep = "")
    sd_col <- paste("amyloid_sd_", variable, sep = "")
    mean_val <- data[[mean_col]][1]
    sd_val <- data[[sd_col]][1]
    
    # Scale residuals by the mean and standard deviation
    z_scores <- scale(residuals, center = FALSE, scale = sd_val)
    
    # Create a new column in the data frame for the scaled z-scores
    z_score_col <- paste(variable, "_z_score_PET_APOE", sep = "")
    
    # Update the data frame with the z_scores
    data <- data %>%
      mutate(!!z_score_col := z_scores)
  }
  
  return(data)
}

# Z-scores for APOE carrier subset
carrier <- compute_z_scores_PET_APOE(carrier_models, carrier)

# Z-scores for non-carrier subset
non_carrier <- compute_z_scores_PET_APOE(non_carrier_models, non_carrier)


```

### Amyloid

```{r}
### Plot of PET amyloid z-scores

# Your list of z_score variables and proxy variables
z_score_PET_APOE <- c("Ab40_diff_z_score_PET_APOE", "Ab42_40_ratio_diff_z_score_PET_APOE"   , "Ab42_diff_z_score_PET_APOE", "ptau181_diff_z_score_PET_APOE", "ptau217_Lilly_diff_z_score_PET_APOE", "ptau217_Janssen_diff_z_score_PET_APOE", "ptau231_diff_z_score_PET_APOE", "ttau_diff_z_score_PET_APOE", "GFAP_diff_z_score_PET_APOE", "NFL_diff_z_score_PET_APOE")

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_PET_APOE))

```

### Individual plots
```{r}

biomarkers <- z_score_PET_APOE <- c("Ab40_diff_z_score_PET_APOE", "Ab42_40_ratio_diff_z_score_PET_APOE"   , "Ab42_diff_z_score_PET_APOE", "ptau181_diff_z_score_PET_APOE", "ptau217_Lilly_diff_z_score_PET_APOE", "ptau217_Janssen_diff_z_score_PET_APOE", "ptau231_diff_z_score_PET_APOE", "ttau_diff_z_score_PET_APOE", "GFAP_diff_z_score_PET_APOE", "NFL_diff_z_score_PET_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create a data frame to store the response variable names
plot_PET_APOE <- data.frame(z_score_var = rep(z_score_PET_APOE, each = nrow(carrier)),
                        amyloid_PET_CL_BL_complete = rep(carrier$amyloid_PET_CL_BL_complete, times = length(z_score_PET_APOE)),
                        value = as.vector(sapply(z_score_PET_APOE, function(z_var) carrier[[z_var]])))

# Map z_score variables to biomarker names
plot_PET_APOE$biomarker_name <- factor(plot_PET_APOE$z_score_var, levels = z_score_PET_APOE, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET_APOE <- ggplot(plot_PET_APOE, aes(x = amyloid_PET_CL_BL_complete, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "Amyloid PET refrerence group in APOE carriers",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET_APOE)

# Print the interactive facet plot
print(interactive_facet_PET)
```


### Combined plots
```{r}
## Combined plots

# Create a data frame to store the response variable names for carrier subset
plot_data_carrier <- data.frame(z_score_var = rep(z_score_PET_APOE, each = nrow(carrier)),
                                amyloid_PET_CL_BL_complete = rep(carrier$amyloid_PET_CL_BL_complete, times = length(z_score_PET_APOE)),
                                value = as.vector(sapply(z_score_PET_APOE, function(z_var) carrier[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable for carrier subset
combined_plot_carrier <- ggplot(plot_data_carrier, aes(x = amyloid_PET_CL_BL_complete, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = -10, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Amyloid PET reference group in APOE Carriers",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(color_palette, z_score_PET_APOE)) +
  theme_minimal()

# Convert ggplot to plotly plot for carrier subset
combined_amyloid_carrier <- ggplotly(combined_plot_carrier)

# Print the interactive plot for carrier subset
print(combined_amyloid_carrier)

```



### Bootstrap Amyloid PET Carriers
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
carrier_df_complete <- carrier[complete.cases(carrier$amyloid_PET_CL_BL_complete), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_PET_APOE) {
  data <- carrier_df_complete[, c("amyloid_PET_CL_BL_complete", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ amyloid_PET_CL_BL_complete")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_PET_APOE) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_PET_APOE) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(carrier_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(carrier_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the amyloid_PET_CL_BL_complete column to averaged_predictions data frame
averaged_predictions$amyloid_PET_CL_BL_complete <- carrier_df_complete$amyloid_PET_CL_BL_complete

```




```{r}


# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_PET_APOE", "Ab42_40_ratio_diff_z_score_PET_APOE"   , "Ab42_diff_z_score_PET_APOE", "ptau181_diff_z_score_PET_APOE", "ptau217_Lilly_diff_z_score_PET_APOE", "ptau217_Janssen_diff_z_score_PET_APOE", "ptau231_diff_z_score_PET_APOE", "ttau_diff_z_score_PET_APOE", "GFAP_diff_z_score_PET_APOE", "NFL_diff_z_score_PET_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = amyloid_PET_CL_BL_complete, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "amyloid_PET_CL_BL_complete", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 12, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)



```





### Non-carrier

### Individual plots
```{r}

biomarkers <- z_score_PET_APOE <- c("Ab40_diff_z_score_PET_APOE", "Ab42_40_ratio_diff_z_score_PET_APOE"   , "Ab42_diff_z_score_PET_APOE", "ptau181_diff_z_score_PET_APOE", "ptau217_Lilly_diff_z_score_PET_APOE", "ptau217_Janssen_diff_z_score_PET_APOE", "ptau231_diff_z_score_PET_APOE", "ttau_diff_z_score_PET_APOE", "GFAP_diff_z_score_PET_APOE", "NFL_diff_z_score_PET_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create a data frame to store the response variable names
plot_PET_APOE <- data.frame(z_score_var = rep(z_score_PET_APOE, each = nrow(non_carrier)),
                        amyloid_PET_CL_BL_complete = rep(non_carrier$amyloid_PET_CL_BL_complete, times = length(z_score_PET_APOE)),
                        value = as.vector(sapply(z_score_PET_APOE, function(z_var) non_carrier[[z_var]])))

# Map z_score variables to biomarker names
plot_PET_APOE$biomarker_name <- factor(plot_PET_APOE$z_score_var, levels = z_score_PET_APOE, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_PET_APOE <- ggplot(plot_PET_APOE, aes(x = amyloid_PET_CL_BL_complete, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = "Amyloid PET refrerence group in APOE non-carriers",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_PET <- ggplotly(facet_PET_APOE)

# Print the interactive facet plot
print(interactive_facet_PET)

```


### Combined plots

```{r}
# Create a data frame to store the response variable names for non-carrier subset
plot_data_non_carrier <- data.frame(z_score_var = rep(z_score_PET_APOE, each = nrow(non_carrier)),
                                    amyloid_PET_CL_BL_complete = rep(non_carrier$amyloid_PET_CL_BL_complete, times = length(z_score_PET_APOE)),
                                    value = as.vector(sapply(z_score_PET_APOE, function(z_var) non_carrier[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable for non-carrier subset
combined_plot_non_carrier <- ggplot(plot_data_non_carrier, aes(x = amyloid_PET_CL_BL_complete, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 12, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = -10, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Amyloid PET reference group in APOE Non-Carriers",
       x = "amyloid_PET_CL_BL_complete",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(color_palette, z_score_PET_APOE)) +
  theme_minimal()

# Convert ggplot to plotly plot for non-carrier subset
combined_amyloid_non_carrier <- ggplotly(combined_plot_non_carrier)

# Print the interactive plot for non-carrier subset
print(combined_amyloid_non_carrier)

```


### Bootstrap Amyloid PET Non-Carriers
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
non_carrier_df_complete <- non_carrier[complete.cases(non_carrier$amyloid_PET_CL_BL_complete), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_PET_APOE) {
  data <- non_carrier_df_complete[, c("amyloid_PET_CL_BL_complete", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ amyloid_PET_CL_BL_complete")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_PET_APOE) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_PET_APOE) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(non_carrier_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(non_carrier_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the amyloid_PET_CL_BL_complete column to averaged_predictions data frame
averaged_predictions$amyloid_PET_CL_BL_complete <- non_carrier_df_complete$amyloid_PET_CL_BL_complete

# List of variables to keep
variables_to_keep <- c(
  "amyloid_PET_CL_BL_complete",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET_APOE", "Ab42_40_ratio_diff_z_score_PET_APOE"   , "Ab42_diff_z_score_PET_APOE", "ptau181_diff_z_score_PET_APOE", "ptau217_Lilly_diff_z_score_PET_APOE", "ptau217_Janssen_diff_z_score_PET_APOE", "ptau231_diff_z_score_PET_APOE", "ttau_diff_z_score_PET_APOE", "GFAP_diff_z_score_PET_APOE", "NFL_diff_z_score_PET_APOE"
)

# Filter the biomark_df to keep only the specified variables
test <- non_carrier %>%
  select(all_of(variables_to_keep))

```




```{r}

# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_PET_APOE", "Ab42_40_ratio_diff_z_score_PET_APOE"   , "Ab42_diff_z_score_PET_APOE", "ptau181_diff_z_score_PET_APOE", "ptau217_Lilly_diff_z_score_PET_APOE", "ptau217_Janssen_diff_z_score_PET_APOE", "ptau231_diff_z_score_PET_APOE", "ttau_diff_z_score_PET_APOE", "GFAP_diff_z_score_PET_APOE", "NFL_diff_z_score_PET_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = amyloid_PET_CL_BL_complete, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "amyloid_PET_CL_BL_complete", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 12, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-4, 4)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)



```



### CSF ratio z-scores

```{r}
# Function to compute z-scores for a list of models based on CSF AB 42/40 ratio
compute_z_scores_CSF_ABRatio <- function(model_list, data) {
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
    residuals <- residuals(model)
    
    # Extract the residuals from the model
    
    # Get mean and standard deviation from the corresponding columns in the data frame based on CSF AB 42/40 ratio
    mean_col <- paste("CSF_mean_", variable, sep = "")
    sd_col <- paste("CSF_sd_", variable, sep = "")
    mean_val <- data[[mean_col]][1]
    sd_val <- data[[sd_col]][1]
    
    # Scale residuals by the mean and standard deviation
    z_scores <- scale(residuals, center = FALSE, scale = sd_val)
    
    # Create a new column in the data frame for the scaled z-scores
    z_score_col <- paste(variable, "_z_score_CSF_ABRatio", sep = "")
    
    # Update the data frame with the z_scores
    data <- data %>%
      mutate(!!z_score_col := z_scores)
  }
  
  return(data)
}

# Apply the function for each list of models
# Z-scores for carrier subset using CSF AB 42/40 ratio reference group
carrier <- compute_z_scores_CSF_ABRatio(carrier_models, carrier)
non_carrier <- compute_z_scores_CSF_ABRatio(non_carrier_models, non_carrier)

# List of CSF z_score variables for AB 42/40 ratio reference group
z_score_CSF_ABRatio <- c("Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio")

# Color palette for z_score variables
color_palette <- rainbow(length(z_score_CSF_ABRatio))

```

### Carrier

### Individual plots
```{r}


biomarkers <- z_score_CSF_ABRatio <- c("Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create a data frame to store the response variable names
plot_data_carrier <- data.frame(z_score_var = rep(z_score_CSF_ABRatio, each = nrow(carrier)),
                                ab42_40_ratio_CSFNC_BL = rep(carrier$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF_ABRatio)),
                                value = as.vector(sapply(z_score_CSF_ABRatio, function(z_var) carrier[[z_var]])))

# Map z_score variables to biomarker names
plot_data_carrier$biomarker_name <- factor(plot_data_carrier$z_score_var, levels = z_score_CSF_ABRatio, labels = biomarker_names)


# Plot ggplot with loess smoothing for each z_score variable
facet_CSF_APOE <- ggplot(plot_data_carrier, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = " ab42_40_ratio_CSF reference group in APOE-Œµ4 carriers",
       x = " ab42_40_ratio_CSF",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_x_continuous(trans = "reverse") +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

facet_CSF_APOE

# Convert ggplot to Plotly
interactive_facet_CSF <- ggplotly(facet_CSF_APOE)

# Print the interactive facet plot
print(interactive_facet_CSF)
```


### Combined plot

```{r}
### Combined biomarkers plot for carrier subset


plot_data_carrier <- data.frame(z_score_var = rep(z_score_CSF_ABRatio, each = nrow(carrier)),
                                ab42_40_ratio_CSFNC_BL = rep(carrier$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF_ABRatio)),
                                value = as.vector(sapply(z_score_CSF_ABRatio, function(z_var) carrier[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable for carrier subset
combined_plot_carrier <- ggplot(plot_data_carrier, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 0.1, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "CSF AB 42/40 ratio reference group in carriers",
       x = "ab42_40_ratio_CSFNC_BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_CSF_ABRatio)) +
  scale_x_continuous(trans = "reverse") +
  theme_minimal()

# Convert ggplot to interactive plot using ggplotly for carrier subset
combined_CSF_carrier <- ggplotly(combined_plot_carrier)

# Print the interactive plot for carrier subset
print(combined_CSF_carrier)

```



### Bootstrap CSF Ab 42/40 in Carriers
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
carrier_df_complete <- carrier[complete.cases(carrier$ab42_40_ratio_CSFNC_BL), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_CSF_ABRatio) {
  data <- carrier_df_complete[, c("ab42_40_ratio_CSFNC_BL", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ ab42_40_ratio_CSFNC_BL")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_CSF_ABRatio) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_CSF_ABRatio) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(carrier_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(carrier_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the ab42_40_ratio_CSFNC_BL column to averaged_predictions data frame
averaged_predictions$ab42_40_ratio_CSFNC_BL <- carrier_df_complete$ab42_40_ratio_CSFNC_BL


# List of variables to keep
variables_to_keep <- c(
  "ab42_40_ratio_CSFNC_BL",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio"
)

# Filter the biomark_df to keep only the specified variables
test <- carrier %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = ab42_40_ratio_CSFNC_BL, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "ab42_40_ratio_CSFNC_BL", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 0.071, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name)) +
    scale_x_continuous(trans = "reverse")
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```




### Non-Carrier

### Individual plots
```{r}

biomarkers <- z_score_CSF_ABRatio <- c("Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create a data frame to store the response variable names
plot_data_non_carrier <- data.frame(z_score_var = rep(z_score_CSF_ABRatio, each = nrow(non_carrier)),
                                ab42_40_ratio_CSFNC_BL = rep(non_carrier$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF_ABRatio)),
                                value = as.vector(sapply(z_score_CSF_ABRatio, function(z_var) non_carrier[[z_var]])))

# Map z_score variables to biomarker names
plot_data_non_carrier$biomarker_name <- factor(plot_data_non_carrier$z_score_var, levels = z_score_CSF_ABRatio, labels = biomarker_names)


# Plot ggplot with loess smoothing for each z_score variable
facet_CSF_APOE <- ggplot(plot_data_non_carrier, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  labs(title = " ab42_40_ratio_CSF reference group in APOE-Œµ4 non-carriers",
       x = " ab42_40_ratio_CSF",
       y = "Rate of change (z-score)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_x_continuous(trans = "reverse") +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to Plotly
interactive_facet_CSF <- ggplotly(facet_CSF_APOE)

# Print the interactive facet plot
print(interactive_facet_CSF)
```


### Combined plot
```{r}
### Combined biomarkers plot for non-carrier subset

# Create a data frame to store the response variable names for non-carrier subset
plot_data_non_carrier <- data.frame(z_score_var = rep(z_score_CSF_ABRatio, each = nrow(non_carrier)),
                                    ab42_40_ratio_CSFNC_BL = rep(non_carrier$ab42_40_ratio_CSFNC_BL, times = length(z_score_CSF_ABRatio)),
                                    value = as.vector(sapply(z_score_CSF_ABRatio, function(z_var) non_carrier[[z_var]])))

# Plot ggplot with loess smoothing for each z_score variable for non-carrier subset
combined_plot_non_carrier <- ggplot(plot_data_non_carrier, aes(x = ab42_40_ratio_CSFNC_BL, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 0.071, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 0.1, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "CSF AB 42/40 ratio reference group in non-carriers",
       x = "ab42_40_ratio_CSFNC_BL",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_CSF_ABRatio)) +
  scale_x_continuous(trans = "reverse") +
  theme_minimal()

# Convert ggplot to interactive plot using ggplotly for non-carrier subset
combined_CSF_non_carrier <- ggplotly(combined_plot_non_carrier)

# Print the interactive plot for non-carrier subset
print(combined_CSF_non_carrier)
```


### Bootstrap CSF Ab 42/40 in Non-Carriers
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of amyloid_PET_CL_BL_complete
non_carrier_df_complete <- non_carrier[complete.cases(non_carrier$ab42_40_ratio_CSFNC_BL), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_CSF_ABRatio) {
  data <- non_carrier_df_complete[, c("ab42_40_ratio_CSFNC_BL", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ ab42_40_ratio_CSFNC_BL")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_CSF_ABRatio) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_CSF_ABRatio) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(non_carrier_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(non_carrier_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the ab42_40_ratio_CSFNC_BL column to averaged_predictions data frame
averaged_predictions$ab42_40_ratio_CSFNC_BL <- non_carrier_df_complete$ab42_40_ratio_CSFNC_BL


# List of variables to keep
variables_to_keep <- c(
  "ab42_40_ratio_CSFNC_BL",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio"
)

# Filter the biomark_df to keep only the specified variables
test <- non_carrier %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- c("Ab40_diff_z_score_CSF_ABRatio", "Ab42_40_ratio_diff_z_score_CSF_ABRatio", "Ab42_diff_z_score_CSF_ABRatio", "ptau181_diff_z_score_CSF_ABRatio", "ptau217_Lilly_diff_z_score_CSF_ABRatio", "ptau217_Janssen_diff_z_score_CSF_ABRatio", "ptau231_diff_z_score_CSF_ABRatio", "ttau_diff_z_score_CSF_ABRatio", "GFAP_diff_z_score_CSF_ABRatio", "NFL_diff_z_score_CSF_ABRatio")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = ab42_40_ratio_CSFNC_BL, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "ab42_40_ratio_CSFNC_BL", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    geom_vline(xintercept = 0.071, alpha = 0.7, color = 'red', linetype = 2) +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name)) +
    scale_x_continuous(trans = "reverse")
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```


### AGE


```{r}
# APOE, Age models

# Function for multiple regression
perform_mult_regression <- function(data, dependent_variable, covariates) {
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  model <- lm(formula, data = data, na.action = 'na.exclude')
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  return(result)
}

covariates <- "Sex"

# Carrier model
carrier_age_models <- vector("list", length = 10)

for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(carrier, variable, covariates)
  carrier_age_models[[i]] <- model_result
}

# Non-carrier model
non_carrier_age_models <- vector("list", length = 10)

for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(non_carrier, variable, covariates)
  non_carrier_age_models[[i]] <- model_result
}

```



```{r}
# APOE, Age reference groups

## Carrier age quantiles
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31 

## Non-carrier age quantiles
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31  

# Carrier reference groups

# Carrier age
residuals_age_carrier <- list()
for (i in seq_along(carrier_age_models)) {
  model <- carrier_age_models[[i]]$model
  residuals_subset <- residuals(model)[carrier$Age_V1S1 < 54.31 ]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  residuals_age_carrier[[i]] <- list(
    model_name = carrier_age_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  carrier[paste0("age_mean_", carrier_age_models[[i]]$dependent_variable)] <- residuals_mean
  carrier[paste0("age_sd_", carrier_age_models[[i]]$dependent_variable)] <- residuals_sd
}
age_carrier_df <- do.call(rbind, residuals_age_carrier)

# Non carrier age
residuals_age_noncarrier <- list()
for (i in seq_along(non_carrier_age_models)) {
  model <- non_carrier_age_models[[i]]$model
  residuals_subset <- residuals(model)[non_carrier$Age_V1S1 < 54.31 ]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  residuals_age_noncarrier[[i]] <- list(
    model_name = non_carrier_age_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  non_carrier[paste0("age_mean_", non_carrier_age_models[[i]]$dependent_variable)] <- residuals_mean
  non_carrier[paste0("age_sd_", non_carrier_age_models[[i]]$dependent_variable)] <- residuals_sd
}
age_noncarrier_df <- do.call(rbind, residuals_age_noncarrier)

```



```{r}
# Compute z-scores for APOE and Age models
compute_z_scores_AGE_APOE <- function(model_list, data) {
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
    residuals <- residuals(model)
    
    # Get mean and standard deviation
    mean_col <- paste("age_mean_", variable, sep = "")
    sd_col <- paste("age_sd_", variable, sep = "")
    mean_val <- data[[mean_col]][1]
    sd_val <- data[[sd_col]][1]
    
    # Scale residuals by the mean and standard deviation
    z_scores <- scale(residuals, center = FALSE, scale = sd_val)
    
    # Create a new column in the data frame for the scaled z-scores
    z_score_col <- paste(variable, "_z_score_AGE_APOE", sep = "")
    
    # Update the data frame with the z_scores
    data <- data %>%
      mutate(!!z_score_col := z_scores)
  }
  
  return(data)
}

# Z-scores for APOE carrier subset
carrier <- compute_z_scores_AGE_APOE(carrier_age_models, carrier)

# Z-scores for non-carrier subset
non_carrier <- compute_z_scores_AGE_APOE(non_carrier_age_models, non_carrier)

```



```{r}
### Plot of PET amyloid z-scores

# Your list of z_score variables and proxy variables
z_score_AGE_APOE <- c("Ab40_diff_z_score_AGE_APOE", "Ab42_40_ratio_diff_z_score_AGE_APOE", "Ab42_diff_z_score_AGE_APOE", "ptau181_diff_z_score_AGE_APOE", "ptau217_Lilly_diff_z_score_AGE_APOE", "ptau217_Janssen_diff_z_score_AGE_APOE", "ptau231_diff_z_score_AGE_APOE", "ttau_diff_z_score_AGE_APOE", "GFAP_diff_z_score_AGE_APOE", "NFL_diff_z_score_AGE_APOE")
   

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_AGE_APOE))

```


### Carrier Age

### Individual plots

```{r}

biomarkers <- z_score_AGE_APOE <- c("Ab40_diff_z_score_AGE_APOE", "Ab42_40_ratio_diff_z_score_AGE_APOE", "Ab42_diff_z_score_AGE_APOE", "ptau181_diff_z_score_AGE_APOE", "ptau217_Lilly_diff_z_score_AGE_APOE", "ptau217_Janssen_diff_z_score_AGE_APOE", "ptau231_diff_z_score_AGE_APOE", "ttau_diff_z_score_AGE_APOE", "GFAP_diff_z_score_AGE_APOE", "NFL_diff_z_score_AGE_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")


plot_data_carrier <- data.frame(z_score_var = rep(z_score_AGE_APOE, each = nrow(carrier)),
                                Age_V1S1 = rep(carrier$Age_V1S1, times = length(z_score_AGE_APOE)),
                                value = as.vector(sapply(z_score_AGE_APOE, function(z_var) carrier[[z_var]])))

# Map z_score variables to biomarker names
plot_data_carrier$biomarker_name <- factor(plot_data_carrier$z_score_var, levels = z_score_AGE_APOE, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_plot <- ggplot(plot_data_carrier, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  labs(title = "Age reference group in carriers",
       x = "Age_V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to interactive plot using ggplotly
facet_Age <- ggplotly(facet_plot)

# Print the interactive plot
print(facet_Age)
```


### Combined plots
```{r}

## Combined plots

plot_data_carrier <- data.frame(z_score_var = rep(z_score_AGE_APOE, each = nrow(carrier)),
                                Age_V1S1 = rep(carrier$Age_V1S1, times = length(z_score_AGE_APOE)),
                                value = as.vector(sapply(z_score_AGE_APOE, function(z_var) carrier[[z_var]])))


# Plot ggplot with loess smoothing for each z_score variable for carrier subset
combined_plot_carrier_age <- ggplot(plot_data_carrier, aes(x = Age_V1S1, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 54.72, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 0.1, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Age reference group in carriers",
       x = "Age V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_AGE_APOE)) +
  theme_minimal() +
  xlim(49, 75)

# Convert ggplot to plotly plot for carrier subset
combined_age_carrier <- ggplotly(combined_plot_carrier_age)

# Print the interactive plot for carrier subset
combined_age_carrier

```


### Bootstrap AGE and APOE Carrier
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
carrier_df_complete <- carrier[complete.cases(carrier$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_AGE_APOE) {
  data <- carrier_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_AGE_APOE) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_AGE_APOE) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(carrier_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(carrier_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- carrier_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <-z_score_AGE_APOE <- c("Ab40_diff_z_score_AGE_APOE", "Ab42_40_ratio_diff_z_score_AGE_APOE", "Ab42_diff_z_score_AGE_APOE", "ptau181_diff_z_score_AGE_APOE", "ptau217_Lilly_diff_z_score_AGE_APOE", "ptau217_Janssen_diff_z_score_AGE_APOE", "ptau231_diff_z_score_AGE_APOE", "ttau_diff_z_score_AGE_APOE", "GFAP_diff_z_score_AGE_APOE", "NFL_diff_z_score_AGE_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```



### Non-carrier

### Individual plots
```{r}

biomarkers <- z_score_AGE_APOE <- c("Ab40_diff_z_score_AGE_APOE", "Ab42_40_ratio_diff_z_score_AGE_APOE", "Ab42_diff_z_score_AGE_APOE", "ptau181_diff_z_score_AGE_APOE", "ptau217_Lilly_diff_z_score_AGE_APOE", "ptau217_Janssen_diff_z_score_AGE_APOE", "ptau231_diff_z_score_AGE_APOE", "ttau_diff_z_score_AGE_APOE", "GFAP_diff_z_score_AGE_APOE", "NFL_diff_z_score_AGE_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

plot_data_non_carrier <- data.frame(z_score_var = rep(z_score_AGE_APOE, each = nrow(non_carrier)),
                                Age_V1S1 = rep(non_carrier$Age_V1S1, times = length(z_score_AGE_APOE)),
                                value = as.vector(sapply(z_score_AGE_APOE, function(z_var) non_carrier[[z_var]])))

# Map z_score variables to biomarker names
plot_data_non_carrier$biomarker_name <- factor(plot_data_non_carrier$z_score_var, levels = z_score_AGE_APOE, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable
facet_plot <- ggplot(plot_data_non_carrier, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +
  labs(title = "Age reference group in non-carriers",
       x = "Age_V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to interactive plot using ggplotly
facet_Age <- ggplotly(facet_plot)

# Print the interactive plot
print(facet_Age)
```



### Non-Carrier Age

```{r}
### Combined plot

## Combined plots

plot_data_non_carrier <- data.frame(z_score_var = rep(z_score_AGE_APOE, each = nrow(non_carrier)),
                                Age_V1S1 = rep(non_carrier$Age_V1S1, times = length(z_score_AGE_APOE)),
                                value = as.vector(sapply(z_score_AGE_APOE, function(z_var) non_carrier[[z_var]])))


# Plot ggplot with loess smoothing for each z_score variable for carrier subset
combined_plot_non_carrier_age <- ggplot(plot_data_non_carrier, aes(x = Age_V1S1, y = value, color = z_score_var)) +
  geom_smooth(method = "loess", linetype = 2, span = 0.9, aes(fill = z_score_var), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 2, linetype = "solid", alpha = 0.5) +  
  geom_vline(xintercept = 54.002, linetype = "dotted", alpha = 0.5, color = 'red') +
  annotate("text", x = 0.1, y = 2.2, label = "2 s.d.", size = 3, fontface = 'bold') +
  labs(title = "Age reference group in non-carriers",
       x = "Age V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(color_palette, z_score_AGE_APOE)) +
  theme_minimal() +
  xlim(49, 70)

# Convert ggplot to plotly plot for carrier subset
combined_age_non_carrier <- ggplotly(combined_plot_non_carrier_age)

# Print the interactive plot for carrier subset
combined_age_non_carrier

```

### Bootstrap AGE and APOE Non-Carrier
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
non_carrier_df_complete <- non_carrier[complete.cases(non_carrier$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_AGE_APOE) {
  data <- non_carrier_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_AGE_APOE) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_AGE_APOE) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(non_carrier_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(non_carrier_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- non_carrier_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_PET",
  "Ab42_40_ratio_diff_z_score_PET",
  "Ab42_diff_z_score_PET",
  "ptau181_diff_z_score_PET",
  "ptau217_Lilly_diff_z_score_PET",
  "ptau217_Janssen_diff_z_score_PET",
  "ptau231_diff_z_score_PET",
  "ttau_diff_z_score_PET",
  "GFAP_diff_z_score_PET",
  "NFL_diff_z_score_PET"
)

# Filter the biomark_df to keep only the specified variables
test <- biomark_df %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <-z_score_AGE_APOE <- c("Ab40_diff_z_score_AGE_APOE", "Ab42_40_ratio_diff_z_score_AGE_APOE", "Ab42_diff_z_score_AGE_APOE", "ptau181_diff_z_score_AGE_APOE", "ptau217_Lilly_diff_z_score_AGE_APOE", "ptau217_Janssen_diff_z_score_AGE_APOE", "ptau231_diff_z_score_AGE_APOE", "ttau_diff_z_score_AGE_APOE", "GFAP_diff_z_score_AGE_APOE", "NFL_diff_z_score_AGE_APOE")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-1, 1)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```

### Amyiloid status (A+ / A-)

```{r}

A_positive <- biomark_df[!is.na(biomark_df$A_status_BL) & biomark_df$A_status_BL == "A+", ]
A_negative <- biomark_df[!is.na(biomark_df$A_status_BL) & biomark_df$A_status_BL == "A-", ]


# Function for multiple regression
perform_mult_regression <- function(data, dependent_variable, covariates) {
  formula <- as.formula(paste(dependent_variable, "~", paste(covariates, collapse = "+")))
  model <- lm(formula, data = data, na.action = 'na.exclude')
  result <- list(
    dependent_variable = dependent_variable,
    model = model,
    summary_result = summary(model)
  )
  return(result)
}

covariates <- "Sex"

# Carrier model
A_positive_age_models <- vector("list", length = 10)

for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(A_positive, variable, covariates)
  A_positive_age_models[[i]] <- model_result
}

# Non-carrier model
A_negative_age_models <- vector("list", length = 10)

for (i in seq_along(difference_cols)) {
  variable <- difference_cols[i]
  model_result <- perform_mult_regression(A_negative, variable, covariates)
  A_negative_age_models[[i]] <- model_result
}

```



```{r}
# A status, Age reference groups

## A+ age quantiles
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31  

## A- age quantiles
quantile(biomark_df$Age_V1S1, probs = 0.10, na.rm = TRUE) # 54.31   

# A status reference groups

# A+ age
residuals_age_A_positive <- list()
for (i in seq_along(A_positive_age_models)) {
  model <- A_positive_age_models[[i]]$model
  residuals_subset <- residuals(model)[A_positive$Age_V1S1 < 54.31 ]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  residuals_age_A_positive[[i]] <- list(
    model_name = A_positive_age_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  A_positive[paste0("age_mean_", A_positive_age_models[[i]]$dependent_variable)] <- residuals_mean
  A_positive[paste0("age_sd_", A_positive_age_models[[i]]$dependent_variable)] <- residuals_sd
}
age_A_positive_df <- do.call(rbind, residuals_age_A_positive)

# Non carrier age
residuals_age_A_negative <- list()
for (i in seq_along(A_negative_age_models)) {
  model <- A_negative_age_models[[i]]$model
  residuals_subset <- residuals(model)[A_negative$Age_V1S1 < 54.31 ]
  residuals_mean <- mean(residuals_subset, na.rm = TRUE)
  residuals_sd <- sd(residuals_subset, na.rm = TRUE)
  
  residuals_age_A_negative[[i]] <- list(
    model_name = A_negative_age_models[[i]]$dependent_variable,
    residuals_mean = residuals_mean,
    residuals_sd = residuals_sd
  )
  A_negative[paste0("age_mean_", A_negative_age_models[[i]]$dependent_variable)] <- residuals_mean
  A_negative[paste0("age_sd_", A_negative_age_models[[i]]$dependent_variable)] <- residuals_sd
}
age_A_negative_df <- do.call(rbind, residuals_age_A_negative)

```



```{r}
# Compute z-scores for APOE and Age models
compute_z_scores_AGE_A_status <- function(model_list, data) {
  for (i in seq_along(model_list)) {
    model <- model_list[[i]]$model
    variable <- model_list[[i]]$dependent_variable
    
    residuals <- residuals(model)
    
    # Get mean and standard deviation
    mean_col <- paste("age_mean_", variable, sep = "")
    sd_col <- paste("age_sd_", variable, sep = "")
    mean_val <- data[[mean_col]][1]
    sd_val <- data[[sd_col]][1]
    
    # Scale residuals by the mean and standard deviation
    z_scores <- scale(residuals, center = FALSE, scale = sd_val)
    
    # Create a new column in the data frame for the scaled z-scores
    z_score_col <- paste(variable, "_z_score_AGE_A_status", sep = "")
    
    # Update the data frame with the z_scores
    data <- data %>%
      mutate(!!z_score_col := z_scores)
  }
  
  return(data)
}

# Z-scores for A+ status subset
A_positive <- compute_z_scores_AGE_A_status(A_positive_age_models, A_positive)

# Z-scores for A- status subset
A_negative <- compute_z_scores_AGE_A_status(A_negative_age_models, A_negative)

```

```{r}

# Your list of z_score variables and proxy variables
z_score_AGE_A_status <- c("Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status")
   

# Define a color palette for z_score variables
color_palette <- rainbow(length(z_score_AGE_A_status))

```



### A+ Age

```{r}

## Combined plots

biomarkers <-z_score_AGE_A_status <- c("Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")


plot_data_A_positive <- data.frame(z_score_var = rep(z_score_AGE_A_status, each = nrow(A_positive)),
                                Age_V1S1 = rep(A_positive$Age_V1S1, times = length(z_score_AGE_A_status)),
                                value = as.vector(sapply(z_score_AGE_A_status, function(z_var) A_positive[[z_var]])))


# Map z_score variables to biomarker names
plot_data_A_positive$biomarker_name <- factor(plot_data_A_positive$z_score_var, levels = z_score_AGE_A_status, labels = biomarker_names)


# Plot ggplot with loess smoothing for each z_score variable for A_positive subset
combined_plot_A_positive_age <- ggplot(plot_data_A_positive, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1, se = TRUE) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2)  +
  labs(title = "Age reference group in A+ status",
       x = "Age V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to plotly plot for carrier subset
combined_age_A_positive <- ggplotly(combined_plot_A_positive_age)

# Print the interactive plot for carrier subset
combined_age_A_positive

```

### Bootstrap AGE and A+ status
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
A_positive_df_complete <- A_positive[complete.cases(A_positive$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_AGE_A_status) {
  data <- A_positive_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_AGE_A_status) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_AGE_A_status) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(A_positive_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(A_positive_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- A_positive_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status"
)

# Filter the biomark_df to keep only the specified variables
test <- A_positive %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- z_score_AGE_A_status <- c("Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-2, 2)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```


### A- Age

```{r}

## Combined plots

biomarkers <- z_score_AGE_A_status <- c("Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

plot_data_A_negative <- data.frame(z_score_var = rep(z_score_AGE_A_status, each = nrow(A_negative)),
                                Age_V1S1 = rep(A_negative$Age_V1S1, times = length(z_score_AGE_A_status)),
                                value = as.vector(sapply(z_score_AGE_A_status, function(z_var) A_negative[[z_var]])))


# Map z_score variables to biomarker names
plot_data_A_negative$biomarker_name <- factor(plot_data_A_negative$z_score_var, levels = z_score_AGE_A_status, labels = biomarker_names)

# Plot ggplot with loess smoothing for each z_score variable for A_positive subset
combined_plot_A_negative_age <- ggplot(plot_data_A_negative, aes(x = Age_V1S1, y = value, color = biomarker_name)) +
  geom_smooth(method = "loess", span = 0.9, aes(fill = biomarker_name), alpha = 0.1) +
  geom_hline(yintercept = 0, linetype = "dotted", alpha = 0.2) +  
  labs(title = "Age reference group in A- status",
       x = "Age V1S1",
       y = "Rate of change (z-scores)") +
  scale_color_manual(values = setNames(biomarker_colors, biomarker_names)) +
  scale_fill_manual(values = setNames(biomarker_colors, biomarker_names)) +
  theme_minimal() +
  facet_wrap(~ biomarker_name, scales = "free_y")

# Convert ggplot to plotly plot for carrier subset
combined_age_A_negative <- ggplotly(combined_plot_A_negative_age)

# Print the interactive plot for carrier subset
combined_age_A_negative

```

### Bootstrap AGE and A- status
```{r}
loess_fit <- function(formula, data, indices) {
  d <- data[indices, ]
  
  # Order columns from bigger to smaller
  ordered_cols <- names(sort(-sapply(d, function(x) sum(!is.na(x)))))
  
  # Find nearest bigger non-NA value for each predictor variable
  for (col in ordered_cols) {
    if (anyNA(d[[col]])) {
      for (i in which(is.na(d[[col]]))) {
        j <- 1
        while (i + j <= length(d[[col]])) {
          if (!is.na(d[[col]][i + j])) {
            d[[col]][i] <- d[[col]][i + j]
            break
          }
          j <- j + 1
        }
      }
    }
  }
  
  fit <- loess(formula, data = d)
  pred <- predict(fit, newdata = data)
  return(pred)
}

# Bootstrap function to obtain coefficients for each variable
bootstrap_loess_coef <- function(data, formula, nboot = 1000) {
  boot_res <- boot(data, statistic = loess_fit, R = nboot, formula = formula)
  return(boot_res)
}

# List to store bootstrapped coefficients for each variable
boot_results <- list()

# Subset data to only include complete cases of Age_V1S1
A_negative_df_complete <- A_negative[complete.cases(A_negative$Age_V1S1), ]

# Loop through each variable and perform bootstrapping
for (variable in z_score_AGE_A_status) {
  data <- A_negative_df_complete[, c("Age_V1S1", variable)]
  boot_results[[variable]] <- bootstrap_loess_coef(data = data, formula = as.formula(paste(variable, "~ Age_V1S1")))
}

# Access bootstrapped coefficients for each variable
for (variable in z_score_AGE_A_status) {
  cat("Bootstrapped coefficients for", variable, ":\n")
}

# Initialize a list to store averaged predictions and standard errors for each variable
averaged_predictions <- list()

# Loop through each variable to calculate averaged predictions and standard errors
for (variable in z_score_AGE_A_status) {
  
  # Initialize an empty vector to store predictions from each iteration
  predictions <- numeric(nrow(A_negative_df_complete))
  
  # Initialize an empty matrix to store predictions from each iteration
  predictions_matrix <- matrix(NA, nrow = nrow(A_negative_df_complete), ncol = 1000)
  
  # Extract predictions from each iteration and aggregate them
  for (i in 1:1000) {
    predictions_matrix[, i] <- boot_results[[variable]]$t[i,]
    predictions <- predictions + boot_results[[variable]]$t[i,]
  }
  
  # Calculate the average prediction across all iterations
  averaged_predictions[[variable]] <-  apply(predictions_matrix, 1, \(x) mean(x, na.rm = T))
  
  # Calculate the standard error across all iterations and add it to the averaged_predictions dataframe
  averaged_predictions[[paste(variable, "_se", sep = "")]] <- apply(predictions_matrix, 1, \(x) sd(x, na.rm = T))
}

# Convert averaged_predictions to a data frame
averaged_predictions <- as.data.frame(averaged_predictions)

# Add the Age_V1S1 column to averaged_predictions data frame
averaged_predictions$Age_V1S1 <- A_negative_df_complete$Age_V1S1


# List of variables to keep
variables_to_keep <- c(
  "Age_V1S1",
  "days_diff",
  "Ab40_diff",
  "Ab42_40_ratio_diff",
  "Ab42_diff",
  "ptau181_diff",
  "ptau231_diff",
  "ptau217_Lilly_diff",
  "ptau217_Janssen_diff",
  "ttau_diff",
  "GFAP_diff",
  "NFL_diff",
  "Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status"
)

# Filter the biomark_df to keep only the specified variables
test <- A_negative %>%
  select(all_of(variables_to_keep))
```

### Bootstrap plots
```{r}

# List of biomarkers
biomarkers <- z_score_AGE_A_status <- c("Ab40_diff_z_score_AGE_A_status",          
"Ab42_40_ratio_diff_z_score_AGE_A_status",   "Ab42_diff_z_score_AGE_A_status" , "ptau181_diff_z_score_AGE_A_status", "ptau217_Lilly_diff_z_score_AGE_A_status",
"ptau217_Janssen_diff_z_score_AGE_A_status", "ptau231_diff_z_score_AGE_A_status", "ttau_diff_z_score_AGE_A_status", "GFAP_diff_z_score_AGE_A_status",         
"NFL_diff_z_score_AGE_A_status")

# Vector of colors for each biomarker
biomarker_colors <- c("#F8766D", "#A3A500", "#D89000" ,"#00BFC4", "#00B0F6", "#9590FF","#E76BF3", "#FF62BC" , "#39B600", "#00BF7D" )

# Named vector of biomarkers for legends
biomarker_names <- c("Ab40", "Ab42/40 Ratio", "Ab42", 
                     "p-Tau 181", "p-Tau 217 Lilly", "p-Tau 217 Janssen",
                     "p-Tau 231", "Total Tau", "GFAP", "NFL")

# Create plots for each biomarker
plot_list <- list()

for (i in seq_along(biomarkers)) {
  biomarker <- biomarkers[i]
  color <- biomarker_colors[i]
  name <- biomarker_names[i]
  
  p <- ggplot(averaged_predictions, aes(x = Age_V1S1, y = !!sym(biomarker))) +
    geom_smooth(method = "loess", span = 0.3, color = color) +
    geom_ribbon(aes(ymin = !!sym(biomarker) - !!sym(paste0(biomarker, "_se")), 
                    ymax = !!sym(biomarker) + !!sym(paste0(biomarker, "_se"))), 
                fill = color, alpha = 0.1) +
    labs(x = "Age_V1S1", y = "Bootstrap z-scores", title = name) +
    geom_hline(yintercept = 0, alpha = 0.7, color = 'black') +
    theme_minimal() +
    coord_cartesian(ylim = c(-2, 2)) +
    scale_color_manual(values = setNames(color, name))
  
  plot_list[[biomarker]] <- p
}

# Arrange plots in a grid
wrap_plots(plotlist = plot_list, ncol = 4)

```


